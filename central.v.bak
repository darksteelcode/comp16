module central(clk, delayed, instr, step, a, b, result, we);
input clk;
input delayed;
/*
Instructions -all 16 bit
All instructions start with 4 bit opcode
Memory based (_ represents 1 bit) 
| _ _ _ _ | _ _ _ _ _ _ _ _ _ _ _ _ |
|  Opcode | Memory adress (12 bits )|

Reg based (_ represents 1 bit) 
| _ _ _ _ | _ _ _ _ | _ _ _ _ | _ _ _ _ |
|  Opcode | Src reg | Dst reg | Alu op  |
*/

//Instr, and instr split into different parts
input [15:0] instr;

wire [3:0] opcode;
assign opcode = instr[15:12];

wire [12:0] adrs;
assign adrs = instr[11:0];

wire [3:0] srcReg;
assign srcReg = instr[11:8];

wire [3:0] dstReg;
assign dstReg = instr[7:4];

wire [3:0] aluOp;
assign aluOp = instr[3:0];

input [1:0] step;

/*Regs [hex num]:[name]:[abbreviation]
0: A reg (B)
1; B reg (A)
2: Result Reg (RES)
3: Program Counter (PC)
4: Memory Adress Reg (MAR)
5: Memory Data Reg (MDR)

**More regs through 16th reg, no specific purpose yet**

*/

//16 Regs, ecah 16 bits
reg [15:0] regFile [15:0];

//Write Enable for each reg
output reg [15:0] we;

output [15:0] a;
assign a = regFile[0];

output [15:0] b;
assign b = regFile[1];

input [15:0] result;

always @(posedge clk)
begin
	//Set result reg
	regFile[3] <= result;
	case(step)
	2'b00:
		begin
	
		end
	2'b01:
		begin
		
		end
	2'b10:
		begin
		
		end
	2'b11:
		begin
		
		end
	default:
		we <= 16'b0;
	endcase
end
endmodule